---
editor_options:
  markdown:
    wrap: 80
bibliography: references.bib
---

# lakeSR-LS_C2_SRST Data Product {#LS-C2-SRST}

The lakeSR data product is a set of tabular datasets, representing the surface
reflectance (SR) and surface tempearture (ST) data summarized for the point of
inaccessibility (POI) location which is meant to represent pelagic conditions at
a given waterbody (identified by its NHD unique identifier, see Section
\@ref(locs-data-acq)). This data product contains "full stacks" of the Landsat
Collection 2 record - that is, all summarized Landsat data available from all
Landsat missions that met our QA criteria.

## Overview of Aqcuisition Steps

The workflow for data acquisition is as follows:

1.  read in and format the yaml configuration file for the GEE run
    (`b_config_file_poi`, `b_yml_poi`)

2.  reformat the locations file for the GEE run using the configuration file
    (`b_ref_locations_poi`)

3.  determine the WRS-2 path-rows that intersect with the locations file
    (`b_WRS_pathrow_poi`)

4.  filter the locations for those that are completely contained by the WRS-2
    path-row when the automated buffer is added, add the WRS-2 path-rows to the
    reformatted locations, and save distinct location files by path-row for
    easier processing in Python (`b_poi_locs_filtered`)

5.  iteratively run the GEE script per WRS-2 path-row (`b_eeRun_poi`)

6.  check to see that all tasks are complete in GEE before moving to next step
    (`b_poi_tasks_complete`)

7.  check to see if any tasks failed in GEE extraction which is not visible from
    the RStudio IDE (`b_check_for_failed_tasks`)

## Technical Implementation of Acquisition Script

In order to cue Python scripts and map along WRS-2 path-rows within the
{targets} architecture, we use a function (`run_GEE_per_pathrow()`) which writes
the current WRS-2 path-row to a text file, then sources a python script that
uses that text file to run the acquisition for the path-row. Additional details
are provided below to describe the steps in the python script
(`run_GEE_per_pathrow.py`).

### Custom Earth Engine Masking Functions

The first section of `run_GEE_per_pathrow.py` saves custom functions used in the
Landsat stack acquisition. These include data manipulation to create Earth
Engine (EE) objects, custom QA masks, DSWE algorithm, and the functions that
perform the masking and extraction of data from the Landsat image. Below is an
overview of some of the custom masking procedures and their justification, if
applicable. We use the most aggressive masking procedures in the lakeSR product
in order to attempt to have consistent and robust data across such a large area
of data acquisition.

-   `apply_rad_mask`: Masks out all pixels that are radiometrically saturated in
    any optical band using the QA_RADSAT QA band. The Landsat User Guides
    [@usgs-ls47user; @usgs-ls89user] note that radiometrically saturated data
    are "unusable". Saturated bands happen infrequently in Landsat 8 and 9, but
    we still apply this mask to all Landat mission data for continuity.

-   `apply_cf_mask`: Applies mask for any pixels obstructed by clouds and
    snow/ice using the CLOUD_QA band. This is a general QA band that describes
    clouds/snow/ice detected by algorithms defined by the atmospheric processing
    procedure. We have elected to only include pixels that do not contain
    clouds, cloud shadows, dispersed clouds, or snow/ice as defined by this
    band. In particular, we follow the suggestions in the product User Guide
    [@usgs-ls47user; @usgs-ls89user]

    > Users are advised to engage the QA “Dilated Cloud” (bit 1) AND “Cloud”
    > (bit 3) OFF condition to correctly identify clear pixels over water.

-   `apply_sr_aero_mask`: Applies mask for any pixels in Landsat 8 and 9 that
    have 'medium' or 'high' aerosol QA flags from the SR_QA_AEROSOL band.
    Because water is particularly difficult to assess from space, we are more
    aggressive in this mask than suggested by the Landsat 8 and 9 User Guide
    [@usgs-ls89user] which states: "Note that pixels classified as high aerosol
    content are not recommended for use."

-   `apply_opac_mask`: Applies mask to remove pixels where atmospheric opacity
    is greater than 0.3 in Landsat 4, 5, and 7 using the SR_ATMOS_OPACITY band.
    For similar reasons as a more aggressive aerosol mask in Landsat 8 & 9, we
    use this mask in addition to the cloud mask (`apply_cf_mask`). The Landsat
    4-7 User Guide [@usgs-ls47user] states the following about the atmospheric
    opacity values:

    > A general interpretation of atmospheric opacity is that values less than
    > 0.1 are clear, 0.1-0.3 are average, and values greater than 0.3 indicate
    > haze or other cloud situations. SR values from pixels with high
    > atmospheric opacity will be less reliable, especially under high solar
    > zenith angle conditions.

-   `apply_fill_mask_457` and `apply_fill_mask_89`: Applies a mask where any
    band value is 0 before applying scaling factors to bands. Filled values are
    infrequent, however, when acquiring data across such a large area and time,
    they are bound to happen.

-   `apply_realistic_mask_457` and `apply_realistic_mask_89`: Applies a mask
    where any band is less than -0.01 after scaling, indicating overcorrection
    of SR product. While the stated minimum value of the 'valid range' for the
    SR product is 7273 prior to application of scaling factors (0.0000075 after
    scaling), we know that this product has been fine-tuned on terrestrial data
    and small over-corrections of the surface reflectance, especially over dark
    surfaces, is likely to happen. We explicitly allow for very small negative
    reflectance values to be sure we do not remove very deep, oligotrophic
    and/or high DOC water systems from our data set.

### Defining water area

We use the Dynamic Surface Water Extent (DSWE) algorithm to define what pixels
are water within the buffer of our specific locations. DSWE was defined in
@jones2019 for Landsat Collection 1 and re-implemented for Collection 2 as a
Level-3 data product in @usgs-dswe. Implementation of the DSWE algorithm results
in the following values per pixel:

-   a value of 0 indicates no water/fill

-   1 is confident water

-   2 is low confidence water

-   3 is high confidence partial water (or vegetated water)

-   4 is low confidence partial water

Within the scope of lakeSR, we tabulate pixels that are a DSWE value of 1
(DSWE1) for high confidence open water, or what we call DSWE1a - high confidence
open water OR they meet a threshold that may indicate there is surface-level
algae. The algae mask is defined as when a pixel has a DSWE value greater than 1
and the green band value is greater than 0.05 and the red band value is less
than 0.04. This is an experimental mask, so we export both DSWE1 and DSWE1a
summaries within lakeSR. We have found some omission error within DSWE1 for
visible floating scum within river systems and this additional mask captures
many of those pixels without adding unnecessary uncertainty. Downstream users
can choose to use the DSWE1a product if applicable to their research, however,
this threshold was defined in the Illinois and Ohio Rivers and may not be
applicable in all environments.

### Setup

The first 50 lines of the `run_GEE_per_pathrow.py` file import Python modules
(lines 2-8), read in the formatted configuration file (line 11) and assign
environment variables (lines 13-41), read in the text file that stores the
current tile (lines 43-45) created by the `run_GEE_per_tile()` function called
in the `eeRun_poi` target), and read in the locations file created in the target
`poi_locs_WRS_latlon` then subset it for locations that are within the current
tile (lines 47-50).

### Collating Earth Engine objects for extraction

The next section of code (lines 52-129) collates the Landsat stacks and formats
them for data extraction.

Each Earth Engine Image Collection (`ee.ImageCollection` in the script) for each
Landsat mission is filtered for total cloud cover in the scene (`CLOUD_COVER`,
set at \<90%), the date range of interest (all images until 2023-07-01), the
current `tile` path and row value, and then unscaled from the digital number
(DN) values that the data are stored in. Below is a code chunk as an example of
this process for Landsat 7 (lines 61-66). Note that `cloud_thresh`, `yml_start`,
`yml_end` are configuration settings, `w_p` and `w_r` represent the current
*path* and *row* of the WRS-2 tile.

```{python}
#| eval: false
#| echo: true
l7 = (ee.ImageCollection("LANDSAT/LE07/C02/T1_L2")
    .filter(ee.Filter.lt("CLOUD_COVER", ee.Number.parse(str(cloud_thresh))))
    .filter(ee.Filter.eq("WRS_PATH", w_p))
    .filter(ee.Filter.eq("WRS_ROW", w_r))
    .filterDate(yml_start, yml_end)
    .map(apply_scale_factors))
```

The function `apply_scale_factors()` is a prescribed function which is
consistent across all Landsat Collection 2 Level 2 SR and ST products to
transform the DN to remote sensing reflectance (Rrs) values with the following
function:

```{python}
#| eval: false
#| echo: true
def apply_scale_factors(image):
  """ Applies scaling factors for Landsat Collection 2 surface reflectance 
  and surface temperature products

  Args:
      image: one ee.Image of an ee.ImageCollection

  Returns:
      ee.Image with band values overwritten by scaling factors
  """
  opticalBands = image.select("SR_B.").multiply(0.0000275).add(-0.2)
  thermalBands = image.select("ST_B.*").multiply(0.00341802).add(149.0)
  return image.addBands(opticalBands, None, True).addBands(thermalBands, None,True)
```

The resulting Landsat 4-7 collections are collated into a single
ee.ImageCollection (line 81), and bands are renamed for continuity (lines
83-96). The same is done for Landsat 8 and 9 (lines 99-129). These two
ee.ImageCollections are handled separately, as the pixel-level metadata within
the scenes from these missions is slightly different and processing must be
completed separately.

### Payload handling

Because GEE is a free service to those at academic or governmental institutions,
there are limits to the total size of a task sent to GEE for completion. For
this reason, tasks are sent to GEE in 10k location increments per tile (for-loop
encompassing lines 132-321). This is an additional step that is taken in
addition to processing per tile to avoid failed tasks.

## Changes from AquaSat v1
