---
editor_options:
  markdown:
    wrap: 80
bibliography: references.bib
---

# lakeSR-LS_C2_SRST Data Product {#LS-C2-SRST}

The lakeSR data product is a set of tabular datasets, representing the surface
reflectance (SR) and surface tempearture (ST) data summarized for the point of
inaccessibility (POI) location which is meant to represent pelagic conditions at
a given waterbody (identified by its NHD unique identifier, see Section
\@ref(locs-data-acq)). This data product contains "full stacks" of the Landsat
Collection 2 record - that is, all summarized Landsat data available from all
Landsat missions that met our QA criteria.

## Overview

The workflow for data acquisition is as follows:

1.  read in and format the yaml configuration file for the GEE run
    (`b_config_file_poi`, `b_yml_poi`)

2.  reformat the locations file for the GEE run using the configuration file
    (`b_ref_locations_poi`)

3.  determine the WRS-2 path-rows that intersect with the locations file
    (`b_WRS_pathrow_poi`)

4.  filter the locations for those that are completely contained by the WRS-2
    path-row when the automated buffer is added, add the WRS-2 path-rows to the
    reformatted locations, and save distinct location files by path-row for
    easier processing in Python (`b_poi_locs_filtered`)

5.  iteratively run the GEE script per WRS-2 path-row (`b_eeRun_poi`)

6.  check to see that all tasks are complete in GEE before moving to next step
    (`b_poi_tasks_complete`)

7.  check to see if any tasks failed in GEE extraction which is not visible from
    the RStudio IDE (`b_check_for_failed_tasks`)

## Technical Implementation of Acquisition Script

In order to cue Python scripts and map along WRS-2 path-rows within the
{targets} architecture, we use a function (`run_GEE_per_pathrow()`) which writes
the current WRS-2 path-row to a text file, then sources a python script that
uses that text file to run the acquisition for the path-row. Additional details
are provided below to describe the steps in the python script
(`run_GEE_per_pathrow.py`).

### Custom Functions

The first section of `run_GEE_per_pathrow.py` saves custom functions used in the
Landsat stack acquisition. These include data manipulation to create Earth
Engine (EE) objects, custom QA masks, DSWE algorithm, and the functions that
perform the masking and extraction of data from the Landsat image. Below is an
overview of some of the custom masking procedures.

-   `apply_rad_mask`: Masks out all pixels that are radiometrically saturated
    using the QA_RADSAT QA band

    -   0: pixel is radiometrically saturated in any optical band

    -   1: pixel is NOT radiometrically saturated in any optical band

-   `apply_cf_mask`: Applies mask for any pixels obstructed by clouds and
    snow/ice

-   `apply_sr_aero_mask`: Applies mask for any pixels in Landsat 8 and 9 that
    have 'medium' or 'high' aerosol QA flags from the SR_QA_AEROSOL band

-   `apply_opac_mask`: Applies mask to remove pixels where atmospheric opacity
    is greater than 0.3 in Landsat 4, 5, and 7.

-   `apply_fill_mask_457` and `apply_fill_mask_89`:

-   `apply_realistic_mask_457` and `apply_realistic_mask_89`:

### Defining water area

`DSWE`: Calculates the dynamic surface water extent per pixel, as defined by
@jones2019 and @usgeologicalsurveya, within the scope of lakeSR we extract DSWE
1 and what we refer to as `DSWE1a`, described later.

-   a value of 0 indicates no water/fill

-   1 is confident water

-   2 is low confidence water

-   3 is high confidence partial water (or vegetated water)

-   4 is low confidence partial water

These functions are

### Setup

The first 50 lines of the ``` run_GEE_per_pathrow``py ``` file import Python
modules (lines 2-8), read in the formatted configuration file (line 11) and
assign environment variables (lines 13-41), read in the text file that stores
the current tile (lines 43-45) created by the `run_GEE_per_tile()` function
called in the `eeRun_poi` target), and read in the locations file created in the
target `poi_locs_WRS_latlon` then subset it for locations that are within the
current tile (lines 47-50).

### Collating Earth Engine objects for extraction

The next section of code (lines 52-129) collates the Landsat stacks and formats
them for data extraction.

Each Earth Engine Image Collection (`ee.ImageCollection` in the script) for each
Landsat mission is filtered for total cloud cover in the scene (`CLOUD_COVER`,
set at \<90%), the date range of interest (all images until 2023-07-01), the
current `tile` path and row value, and then unscaled from the digital number
(DN) values that the data are stored in. Below is a code chunk as an example of
this process for Landsat 7 (lines 61-66). Note that `cloud_thresh`, `yml_start`,
`yml_end` are configuration settings, `w_p` and `w_r` represent the current
*path* and *row* of the WRS-2 tile.

```{python}
#| eval: false
#| echo: true
l7 = (ee.ImageCollection("LANDSAT/LE07/C02/T1_L2")
    .filter(ee.Filter.lt("CLOUD_COVER", ee.Number.parse(str(cloud_thresh))))
    .filter(ee.Filter.eq("WRS_PATH", w_p))
    .filter(ee.Filter.eq("WRS_ROW", w_r))
    .filterDate(yml_start, yml_end)
    .map(apply_scale_factors))
```

The function `apply_scale_factors()` is a prescribed function which is
consistent across all Landsat Collection 2 Level 2 SR and ST products to
transform the DN to remote sensing reflectance (Rrs) values with the following
function:

```{python}
#| eval: false
#| echo: true
def apply_scale_factors(image):
  """ Applies scaling factors for Landsat Collection 2 surface reflectance 
  and surface temperature products

  Args:
      image: one ee.Image of an ee.ImageCollection

  Returns:
      ee.Image with band values overwritten by scaling factors
  """
  opticalBands = image.select("SR_B.").multiply(0.0000275).add(-0.2)
  thermalBands = image.select("ST_B.*").multiply(0.00341802).add(149.0)
  return image.addBands(opticalBands, None, True).addBands(thermalBands, None,True)
```

The resulting Landsat 4-7 collections are collated into a single
ee.ImageCollection (line 81), and bands are renamed for continuity (lines
83-96). The same is done for Landsat 8 and 9 (lines 99-129). These two
ee.ImageCollections are handled separately, as the pixel-level metadata within
the scenes from these missions is slightly different and processing must be
completed separately.

### Payload handling

Because GEE is a free service to those at academic or governmental institutions,
there are limits to the total size of a task sent to GEE for completion. For
this reason, tasks are sent to GEE in 10k location increments per tile (for-loop
encompassing lines 132-321). This is an additional step that is taken in
addition to processing per tile to avoid failed tasks.

## Changes from AquaSat v1
